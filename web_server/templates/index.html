<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Critter World</title>
    <style>
      body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f0f0f0;
      }
      .controls {
        margin: 20px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      input {
        width: 60px;
        margin-right: 10px;
      }
      button {
        padding: 8px 15px;
        border-radius: 5px;
        border: none;
        background-color: #4287f5;
        color: white;
        cursor: pointer;
      }
      canvas {
        border: 2px solid #333;
      }
    </style>
  </head>
  <body>
    <h1>Critter World Viewer</h1>

    <a href="/stats" style="margin-bottom: 20px; font-size: 16px"
      >View Statistics
    </a>

    <div class="controls">
      <label>X: <input type="number" id="x-coord" value="0" /></label>
      <label>Y: <input type="number" id="y-coord" value="0" /></label>
      <label>W: <input type="number" id="width" value="100" /></label>
      <label>H: <input type="number" id="height" value="100" /></label>
      <button id="draw-btn">Draw Map</button>
    </div>

    <canvas
      id="world-canvas"
      width="{{ canvas_size }}"
      height="{{ canvas_size }}"
    ></canvas>

    <script>
      const DEFAULT_GRASS_FOOD = {{ default_grass_food }};

      // --- DOM Elements ---
      const canvas = document.getElementById("world-canvas");
      const ctx = canvas.getContext("2d");
      const xInput = document.getElementById("x-coord");
      const yInput = document.getElementById("y-coord");
      const widthInput = document.getElementById("width");
      const heightInput = document.getElementById("height");
      const drawButton = document.getElementById("draw-btn");

      let currentTerrainData = null;
      let currentView = {
        x: parseInt(xInput.value),
        y: parseInt(yInput.value),
        w: parseInt(widthInput.value),
        h: parseInt(heightInput.value),
      };

      // --- Color Map (must match TerrainType enum names) ---
      const colorMap = {
        WATER: "#4287f5",
        GRASS: "#34a12d",
        DIRT: "#855a38",
        MOUNTAIN: "#a1a2a3",
      };

      // Takes a hex colour and percentage (-1.0 to 1.0) and
      // returns a new hex color from dark to light.
      function shadeColor(color, percent) {
        let R = parseInt(color.substring(1, 3), 16);
        let G = parseInt(color.substring(3, 5), 16);
        let B = parseInt(color.substring(5, 7), 16);

        R = parseInt(R * (1.0 + percent));
        G = parseInt(G * (1.0 + percent));
        B = parseInt(B * (1.0 + percent));

        // CLAMP
        R = R < 255 ? R : 255;
        G = G < 255 ? G : 255;
        B = B < 255 ? B : 255;

        R = R > 0 ? R : 0;
        G = G > 0 ? G : 0;
        B = B > 0 ? B : 0;

        const RR =
          R.toString(16).length == 1 ? "0" + R.toString(16) : R.toString(16);
        const GG =
          G.toString(16).length == 1 ? "0" + G.toString(16) : G.toString(16);
        const BB =
          B.toString(16).length == 1 ? "0" + B.toString(16) : B.toString(16);

        return "#" + RR + GG + BB;
      }

      function interpolateColor(color1, color2, factor) {
        let result = color1.slice()
        let color_1_rgb = [parseInt(color1.substring(1,3), 16), parseInt(color1.substring(3,5), 16), parseInt(color1.substring(5,7), 16)]
        let color_2_rgb = [parseInt(color2.substring(1,3), 16), parseInt(color2.substring(3,5), 16), parseInt(color2.substring(5,7), 16)]

        let final_color_rgb = [0,0,0];

        for (let i = 0; i < 3; i++) {
          final_color_rgb[i] = Math.round((color_1_rgb[i] * (1 - factor)) + (color_2_rgb[i] * factor));
        }

        return "#" + final_color_rgb.map(c => c.toString(16).padStart(2, '0')).join('');
      }

      async function fetchTerrain(view) {
        const apiUrl = `/api/world/terrain?x=${view.x}&y=${view.y}&w=${view.w}&h=${view.h}`;

        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error("Failed to fetch terrain");
        currentTerrainData = await response.json();
      }

      async function fetchCritters(view) {
        const apiUrl = `/api/world/critters?x=${view.x}&y=${view.y}&w=${view.w}&h=${view.h}`;
        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error("Failed to fetch critters");
        return await response.json();
      }

      function drawTerrain(view) {
        if (!currentTerrainData) return;
        const tiles = currentTerrainData.tiles;
        const tileWidth = canvas.width / view.w;
        const tileHeight = canvas.height / view.h;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < tiles.length; i++) {
          const tile = tiles[i];
          const x = i % view.w;
          const y = Math.floor(i / view.w);

          let baseColor;
          if (tile.terrain === 'GRASS') {
            const foodPercent = tile.food_available / DEFAULT_GRASS_FOOD;
            baseColor = interpolateColor(colorMap.DIRT, colorMap.GRASS, foodPercent);
          } else {
            baseColor = colorMap[tile.terrain] || "#000";
          }

          const finalColor = shadeColor(baseColor, tile.height * 0.4);
          ctx.fillStyle = finalColor;
          ctx.fillRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
        }
      }

      // Handles erasing old critters and drawing new ones
      function updateCritterLayer(view, newCritters) {
        if (!currentTerrainData) return;
        const tiles = currentTerrainData.tiles;
        const tileWidth = canvas.width / view.w;
        const tileHeight = canvas.height / view.h;

        // Redraw terrain to "erase" the critters.
        drawTerrain(view);

        // Calculate top-left
        const startX = view.x - view.w / 2;
        const startY = view.y - view.h / 2;

        ctx.fillStyle = "red";
        for (const critter of newCritters) {
          const canvasX = (critter.x - startX) * tileWidth;
          const canvasY = (critter.y - startY) * tileHeight;
          ctx.beginPath();
          ctx.arc(
            canvasX + tileWidth / 2,
            canvasY + tileHeight / 2,
            tileWidth / 2.5,
            0,
            2 * Math.PI
          );
          ctx.fill();
        }
      }

      async function handleManualUpdate() {
        // Update the current view.
        currentView.x = xInput.value;
        currentView.y = yInput.value;
        currentView.w = widthInput.value;
        currentView.h = heightInput.value;

        try {
          await fetchTerrain(currentView);
          drawTerrain(currentView);

          const critterData = await fetchCritters(currentView);
          updateCritterLayer(currentView, critterData.critters);
        } catch (error) {
          console.error(error);
        }
      }

      async function handleLiveUpdate() {
        if (!currentTerrainData) return; // Don't run if the map isn't loaded

        try {
          // Use cached current view.
          const critterData = await fetchCritters(currentView);
          updateCritterLayer(currentView, critterData.critters);
        } catch (error) {
          console.error(error);
        }
      }

      // --- Event Listeners ---
      drawButton.addEventListener("click", handleManualUpdate);
      window.addEventListener("load", handleManualUpdate);
      setInterval(handleLiveUpdate, 3000);
    </script>
  </body>
</html>
